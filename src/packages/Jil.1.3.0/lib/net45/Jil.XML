<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jil</name>
    </assembly>
    <members>
        <member name="T:Jil.DateTimeFormat">
            <summary>
            Specifies the format of DateTime's produced or expected by Jil.
            </summary>
        </member>
        <member name="F:Jil.DateTimeFormat.NewtonsoftStyleMillisecondsSinceUnixEpoch">
            <summary>
            DateTimes will be formatted as "\/Date(##...##)\/" where ##...## is the 
            number of milliseconds since the unix epoch (January 1st, 1970 UTC).
            </summary>
        </member>
        <member name="F:Jil.DateTimeFormat.MillisecondsSinceUnixEpoch">
            <summary>
            DateTimes will be formatted as ##...##, where ##...## is the number
            of milliseconds since the unix epoch (January 1st, 1970 UTC).
            
            This is format can be passed directly to JavaZcript's Date constructor.
            </summary>
        </member>
        <member name="F:Jil.DateTimeFormat.SecondsSinceUnixEpoch">
            <summary>
            DateTimes will be formatted as ##...##, where ##...## is the number
            of seconds since the unix epoch (January 1st, 1970 UTC).
            </summary>
        </member>
        <member name="F:Jil.DateTimeFormat.ISO8601">
            <summary>
            DateTimes will be formatted as "yyyy-MM-ddThh:mm:ssZ" where
            yyyy is the year, MM is the month (starting at 01), dd is the day (starting at 01),
            hh is the hour (starting at 00, continuing to 24), mm is the minute (start at 00),
            and ss is the second (starting at 00).
            
            Examples:
                2011-07-14T19:43:37Z
                2012-01-02T03:04:05Z
            </summary>
        </member>
        <member name="T:Jil.DeserializationException">
            <summary>
            An exception thrown when Jil encounters an error when deserializing a stream.
            </summary>
        </member>
        <member name="P:Jil.DeserializationException.Position">
            <summary>
            The position in the TextReader where an error occurred, if it is available.
            
            This is meant for debugging purposes only, as exactly when Jil decides to abandon deserialization
            and throw an exception is an implementation detail.
            </summary>
        </member>
        <member name="P:Jil.DeserializationException.SnippetAfterError">
            <summary>
            A snippet of text immediately after an error occurred.
            
            This is meant for debugging purposes only, as exactly when Jil decides to abandon deserialization
            and throw an exception is an implementation detail.
            </summary>
        </member>
        <member name="M:Jil.Common.ExtensionMethods.IsAnonymouseClass(System.Type)">
            <summary>
            HACK: This is a best effort attempt to divine if a type is anonymous based on the language spec.
            
            Reference section 7.6.10.6 of the C# language spec as of 2012/11/19
            
            It checks:
                - is a class
                - descends directly from object
                - has [CompilerGenerated]
                - has a single constructor
                - that constructor takes exactly the same parameters as its public properties
                - all public properties are not writable
                - has a private field for every public property
                - overrides Equals(object)
                - overrides GetHashCode()
            </summary>
        </member>
        <member name="T:Jil.InfiniteRecursionException">
            <summary>
            An exception throw when Jil suspects it's in an infinite recursive case.
            
            Note that this is detected heuristically, exactly how many recursions must occur
            before it is thrown depends on the configuration and version of Jil, as well as the object being serialized.
            </summary>
        </member>
        <member name="T:Jil.JSON">
            <summary>
            Fast JSON serializer.
            </summary>
        </member>
        <member name="M:Jil.JSON.SerializeDynamic(System.Object,System.IO.TextWriter,Jil.Options)">
            <summary>
            Serializes the given data to the provided TextWriter.
            
            Pass an Options object to configure the particulars (such as whitespace, and DateTime formats) of
            the produced JSON.  If omitted, Options.Default is used.
            
            Unlike Serialize, this method will inspect the Type of data to determine what serializer to invoke.
            This is not as fast as calling Serialize with a known type.
            
            Note that this lookup only happens on the *root object*, members of type System.Object will not
            be serialized via a dynamic lookup.
            </summary>
        </member>
        <member name="M:Jil.JSON.SerializeDynamic(System.Object,Jil.Options)">
            <summary>
            Serializes the given data, returning the output as a string.
            
            Pass an Options object to configure the particulars (such as whitespace, and DateTime formats) of
            the produced JSON.  If omitted, Options.Default is used.
            
            Unlike Serialize, this method will inspect the Type of data to determine what serializer to invoke.
            This is not as fast as calling Serialize with a known type.
            
            Note that this lookup only happens on the *root object*, members of type System.Object will not
            be serialized via a dynamic lookup.
            </summary>
        </member>
        <member name="M:Jil.JSON.Serialize``1(``0,System.IO.TextWriter,Jil.Options)">
            <summary>
            Serializes the given data to the provided TextWriter.
            
            Pass an Options object to configure the particulars (such as whitespace, and DateTime formats) of
            the produced JSON.  If omitted, Options.Default is used.
            </summary>
        </member>
        <member name="M:Jil.JSON.Serialize``1(``0,Jil.Options)">
            <summary>
            Serializes the given data, returning the output as a string.
            
            Pass an Options object to configure the particulars (such as whitespace, and DateTime formats) of
            the produced JSON.  If omitted, Options.Default is used.
            </summary>
        </member>
        <member name="M:Jil.JSON.Deserialize``1(System.IO.TextReader,Jil.Options)">
            <summary>
            Deserializes JSON from the given TextReader.
            
            Pass an Options object to specify the particulars (such as DateTime formats) of
            the JSON being deserialized.  If omitted, Options.Default is used.
            </summary>
        </member>
        <member name="M:Jil.JSON.Deserialize``1(System.String,Jil.Options)">
            <summary>
            Deserializes JSON from the given string.
            
            Pass an Options object to specify the particulars (such as DateTime formats) of
            the JSON being deserialized.  If omitted, Options.Default is used.
            </summary>
        </member>
        <member name="M:Jil.JSON.DeserializeDynamic(System.IO.TextReader,Jil.Options)">
            <summary>
            Deserializes JSON from the given TextReader, inferring types from the structure of the JSON text.
            
            For the best performance, use the strongly typed Deserialize method when possible.
            </summary>
        </member>
        <member name="M:Jil.JSON.DeserializeDynamic(System.String,Jil.Options)">
            <summary>
            Deserializes JSON from the given string, inferring types from the structure of the JSON text.
            
            For the best performance, use the strongly typed Deserialize method when possible.
            </summary>
        </member>
        <member name="T:Jil.Options">
            <summary>
            Configuration options for Jil serialization, passed to the JSON.Serialize method.
            </summary>
        </member>
        <member name="M:Jil.Options.#ctor(System.Boolean,System.Boolean,System.Boolean,Jil.DateTimeFormat,System.Boolean,System.Boolean)">
            <summary>
            Configuration for Jil serialization options.
            
            Available options:
              prettyPrint - whether or not to include whitespace and newlines for ease of reading
              excludeNulls - whether or not to write object members whose value is null
              jsonp - whether or not the serialized json should be valid for use with JSONP
              dateFormat - the style in which to serialize DateTimes
              includeInherited - whether or not to serialize members declared by an objects base types
              allowHashFunction - whether or not Jil should try to use hashes instead of strings when deserializing object members, malicious content may be able to force member collisions if this is enabled
            </summary>
        </member>
        <member name="M:Jil.Options.ToString">
            <summary>
            Returns a string representation of this Options object.
            
            The format of this may change at any time, it is only meant for debugging.
            </summary>
        </member>
        <member name="M:Jil.Common.Utils.GetAnonymousNameToConstructorMap(System.Type)">
            <summary>
            This returns a map of "name of member" => [Type of member, index of argument to constructor].
            We need this for anonymous types because we can't set properties (they're read-only).
            
            How this works is kind of fun.
            
            By spec, the arguments to the constructor are in declaration order for an anonymous type.
            So: new { A, B, C } => new SomeType(A a, B b, C c)
            
            However there is no way to get declaration order via reflection, it's just not data that's
            preserved.  Furthermore, the names of backing fields for those read-only properties are not
            defined by the spec.
            
            So I got clever.
            
            This method decompiles the constructor to find out which fields are set by which arguments (by index).
            It then decompiles all properties to find out which fields back which properties.
            Then it finally works backwards from each property, taking the property's name type and using it's backing
            field to lookup which index to pass it in as when constructing the anonymous object.
            </summary>
        </member>
    </members>
</doc>
